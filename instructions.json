{
	"copilot-instuctions-nestjs": {
		"prefix": "ci",
		"body": [
			"# Simple NestJs Project Instructions",
			"",
			"## Tech Stack",
			"",
			"- **Runtime:** NestJS (Node.js)",
			"- **Language:** TypeScript (strict mode)",
			"- **Package Manager:** Yarn",
			"- **ORM:** TypeORM",
			"- **Database:** PostgreSQL",
			"- **Testing:** Jest",
			"- **Protocol:** HTTP / REST",
			"",
			"---",
			"",
			"## Project Structure",
			"",
			"- One NestJS module per feature domain.",
			"- Each module owns its controllers, services, and entities.",
			"- Group DTOs in a `dto/` subfolder per module.",
			"- Group entities in an `entities/` subfolder per module.",
			"",
			"---",
			"",
			"## Code Style",
			"",
			"### TypeScript",
			"",
			"- Enable `strict` and `noImplicitAny` in `tsconfig.json`.",
			"- Prefer `interface` over `type` for object shapes.",
			"- Use `enum` only for fixed, known value sets.",
			"- Avoid `any`. Use `unknown` and narrow with guards.",
			"- Add concise JSDoc to public methods and classes.",
			"",
			"### Controllers",
			"",
			"- Keep controllers thin. No business logic.",
			"- One controller per resource (e.g., `TeamsController`).",
			"- Use HTTP decorators: `@Get`, `@Post`, `@Patch`, `@Delete`.",
			"- Return DTOs, never raw entities.",
			"- Apply `@HttpCode` when the default is wrong.",
			"- Use `@Param`, `@Query`, `@Body` for input binding.",
			"",
			"### Services",
			"",
			"- All business logic lives in services.",
			"- Inject dependencies via constructor injection.",
			"- Return plain objects or DTOs, not entities.",
			"- Throw NestJS HTTP exceptions for error cases.",
			"- Keep methods short and single-purpose.",
			"",
			"### DTOs",
			"",
			"- DTOs define the API contract.",
			"- Validate with `class-validator` decorators.",
			"- Transform with `class-transformer` decorators.",
			"- Create separate DTOs for create, update, and response.",
			"- Use `PartialType` or `PickType` to reduce duplication.",
			"",
			"### Entities",
			"",
			"- One entity class per database table.",
			"- Keep entity files in `entities/` per module.",
			"- Use TypeORM decorators: `@Entity`, `@Column`, etc.",
			"- Never expose entities directly in API responses.",
			"- Define relations explicitly with `@ManyToOne`, etc.",
			"",
			"### Error Handling",
			"",
			"- Use NestJS built-in exceptions (e.g., `NotFoundException`).",
			"- Centralize cross-cutting errors in exception filters.",
			"- Return consistent JSON error shapes.",
			"- Never leak stack traces in production.",
			"",
			"### Security",
			"",
			"- Validate all input with DTOs and pipes.",
			"- Sanitize strings to prevent injection attacks.",
			"- Apply auth guards at the controller or route level.",
			"- Use rate limiting on public endpoints.",
			"",
			"---",
			"",
			"## Testing",
			"",
			"### Unit Tests",
			"",
			"- Test services and controllers in isolation.",
			"- Mock all external dependencies.",
			"- Use `jest.fn()` and `jest.spyOn()` for mocking.",
			"- Name test files `*.spec.ts` next to source files.",
			"- Test behavior, not implementation details.",
			"",
			"### E2E Tests",
			"",
			"- Test critical HTTP flows end-to-end.",
			"- Place E2E tests in `test/` with `*.e2e-spec.ts` names.",
			"- Use a test database, never production data.",
			"- Keep E2E tests fast and deterministic.",
			"",
			"### Running Tests",
			"",
			"- `yarn test` — run all unit tests.",
			"- `yarn test:e2e` — run all E2E tests.",
			"- All tests must pass before merging.",
			"",
			"---",
			"",
			"## Build & CI",
			"",
			"- `yarn build` must complete with zero errors.",
			"- `yarn lint` must pass with no warnings.",
			"- Run `yarn build`, `yarn test`, `yarn test:e2e` before merging.",
			"- Use semantic commit messages (e.g., `feature/`, `fix/`).",
			"- Enforce lint, type-check, and tests in CI pipelines.",
			"",
			"---",
			"",
			"## Feature Implementation Checklist",
			"",
			"1. Create or update the module, controller, and service.",
			"2. Define request and response DTOs with validation.",
			"3. Add or update entity if persistence changes.",
			"4. Write unit tests for new or changed logic.",
			"5. Write or update E2E tests for HTTP flows.",
			"6. Run `yarn build` — must succeed with no errors.",
			"7. Run `yarn test` — all unit tests must pass.",
			"8. Run `yarn test:e2e` — all E2E tests must pass.",
			"9. Commit with a semantic message and push."
		],
		"description": "Copilot instructions for NestJs"
	},
	"copilot-instuctions-dotnet": {
		"prefix": "ci-dotnet",
		"body": [
			"# Simple .NET Core Project Instructions",
			"",
			"## Tech Stack",
			"",
			"- **Runtime:** .NET Core / .NET 8+",
			"- **Language:** C# (nullable reference types enabled)",
			"- **Package Manager:** NuGet",
			"- **ORM:** Entity Framework Core",
			"- **Database:** PostgreSQL",
			"- **Testing:** xUnit / NUnit",
			"- **Protocol:** HTTP / REST",
			"",
			"---",
			"",
			"## Project Structure",
			"",
			"- One controller per feature domain.",
			"- Each controller owns its services and models.",
			"- Group DTOs in a `Models/` or `DTOs/` folder per feature.",
			"- Group entities in a `Data/Entities/` folder.",
			"",
			"---",
			"",
			"## Code Style",
			"",
			"### C#",
			"",
			"- Enable nullable reference types in `.csproj`.",
			"- Use `record` for immutable DTOs.",
			"- Use `class` for entities and services.",
			"- Avoid `dynamic`. Use strongly typed objects.",
			"- Add XML documentation to public methods and classes.",
			"",
			"### Controllers",
			"",
			"- Keep controllers thin. No business logic.",
			"- One controller per resource (e.g., `TeamsController`).",
			"- Use HTTP attribute routing: `[HttpGet]`, `[HttpPost]`, `[HttpPut]`, `[HttpDelete]`.",
			"- Return DTOs, never raw entities.",
			"- Use `[ProducesResponseType]` to document responses.",
			"- Use `[FromRoute]`, `[FromQuery]`, `[FromBody]` for input binding.",
			"",
			"### Services",
			"",
			"- All business logic lives in services.",
			"- Inject dependencies via constructor injection.",
			"- Return plain objects or DTOs, not entities.",
			"- Throw appropriate exceptions for error cases.",
			"- Keep methods short and single-purpose.",
			"",
			"### DTOs",
			"",
			"- DTOs define the API contract.",
			"- Use data annotations for validation (`[Required]`, `[MaxLength]`, etc.).",
			"- Create separate DTOs for create, update, and response.",
			"- Use `record` types for immutable request/response DTOs.",
			"",
			"### Entities",
			"",
			"- One entity class per database table.",
			"- Keep entity files in `Data/Entities/` folder.",
			"- Use EF Core data annotations or Fluent API for configuration.",
			"- Never expose entities directly in API responses.",
			"- Define relations explicitly with navigation properties.",
			"",
			"### Error Handling",
			"",
			"- Use built-in exceptions or create custom exceptions.",
			"- Centralize cross-cutting errors in middleware or filters.",
			"- Return consistent JSON error shapes via ProblemDetails.",
			"- Never leak stack traces in production.",
			"",
			"### Security",
			"",
			"- Validate all input with data annotations and model validation.",
			"- Sanitize strings to prevent injection attacks.",
			"- Apply `[Authorize]` at the controller or action level.",
			"- Use rate limiting on public endpoints.",
			"",
			"---",
			"",
			"## Database with PostgreSQL",
			"",
			"### Setup",
			"",
			"- Install `Npgsql.EntityFrameworkCore.PostgreSQL` package.",
			"- Configure connection string in `appsettings.json`.",
			"- Register DbContext in `Program.cs` with Npgsql provider.",
			"",
			"### Migrations",
			"",
			"- Use EF Core migrations to manage schema changes.",
			"- Run `dotnet ef migrations add <MigrationName>` to create.",
			"- Run `dotnet ef database update` to apply migrations.",
			"- Keep migrations in source control.",
			"",
			"### DbContext",
			"",
			"- Define one DbContext class for the application.",
			"- Configure entities via `OnModelCreating` method.",
			"- Use dependency injection to inject DbContext into services.",
			"",
			"---",
			"",
			"## Testing",
			"",
			"### Unit Tests",
			"",
			"- Test services and controllers in isolation.",
			"- Mock all external dependencies with Moq or NSubstitute.",
			"- Name test files `*.Tests.cs` in a separate test project.",
			"- Test behavior, not implementation details.",
			"",
			"### Integration Tests",
			"",
			"- Test critical HTTP flows end-to-end.",
			"- Use `WebApplicationFactory` for integration testing.",
			"- Use a test database, never production data.",
			"- Keep integration tests fast and deterministic.",
			"",
			"### Running Tests",
			"",
			"- `dotnet test` — run all tests.",
			"- All tests must pass before merging.",
			"",
			"---",
			"",
			"## Build & CI",
			"",
			"- `dotnet build` must complete with zero errors.",
			"- `dotnet format --verify-no-changes` to check code formatting.",
			"- Run `dotnet build`, `dotnet test` before merging.",
			"- Use semantic commit messages (e.g., `feature/`, `fix/`).",
			"- Enforce build, format, and tests in CI pipelines.",
			"",
			"---",
			"",
			"## Feature Implementation Checklist",
			"",
			"1. Create or update the controller and service.",
			"2. Define request and response DTOs with validation.",
			"3. Add or update entity if persistence changes.",
			"4. Update DbContext and create migration if needed.",
			"5. Write unit tests for new or changed logic.",
			"6. Write or update integration tests for HTTP flows.",
			"7. Run `dotnet build` — must succeed with no errors.",
			"8. Run `dotnet test` — all tests must pass.",
			"9. Commit with a semantic message and push."
		],
		"description": "Copilot instructions for .NET Core with PostgreSQL"
	}
}