{
	"copilot-instructions-nestjs": {
		"prefix": "ci-nestjs",
		"body": [
			"# Simple NestJs Project Instructions",
			"",
			"## Tech Stack",
			"",
			"- **Runtime:** NestJS (Node.js)",
			"- **Language:** TypeScript (strict mode)",
			"- **Package Manager:** Yarn",
			"- **ORM:** TypeORM",
			"- **Database:** PostgreSQL",
			"- **Testing:** Jest",
			"- **Protocol:** HTTP / REST",
			"",
			"---",
			"",
			"## Project Structure",
			"",
			"- One NestJS module per feature domain.",
			"- Each module owns its controllers, services, and entities.",
			"- Group DTOs in a `dto/` subfolder per module.",
			"- Group entities in an `entities/` subfolder per module.",
			"",
			"---",
			"",
			"## Code Style",
			"",
			"### TypeScript",
			"",
			"- Enable `strict` and `noImplicitAny` in `tsconfig.json`.",
			"- Prefer `interface` over `type` for object shapes.",
			"- Use `enum` only for fixed, known value sets.",
			"- Avoid `any`. Use `unknown` and narrow with guards.",
			"- Add concise JSDoc to public methods and classes.",
			"",
			"### Controllers",
			"",
			"- Keep controllers thin. No business logic.",
			"- One controller per resource (e.g., `TeamsController`).",
			"- Use HTTP decorators: `@Get`, `@Post`, `@Patch`, `@Delete`.",
			"- Return DTOs, never raw entities.",
			"- Apply `@HttpCode` when the default is wrong.",
			"- Use `@Param`, `@Query`, `@Body` for input binding.",
			"",
			"### Services",
			"",
			"- All business logic lives in services.",
			"- Inject dependencies via constructor injection.",
			"- Return plain objects or DTOs, not entities.",
			"- Throw NestJS HTTP exceptions for error cases.",
			"- Keep methods short and single-purpose.",
			"",
			"### DTOs",
			"",
			"- DTOs define the API contract.",
			"- Validate with `class-validator` decorators.",
			"- Transform with `class-transformer` decorators.",
			"- Create separate DTOs for inputs (Request) and outputs (Response).",
			"- Use distinct Response DTOs (e.g. `UserResponseDto`) effectively acting as View Models.",
			"- Map Entities to Response DTOs in the Service layer (or use a mapper/serializer).",
			"- Use `PartialType` or `PickType` to reduce duplication.",
			"",
			"### Entities",
			"",
			"- One entity class per database table.",
			"- Keep entity files in `entities/` per module.",
			"- Use TypeORM decorators: `@Entity`, `@Column`, etc.",
			"- Never expose entities directly in API responses.",
			"- Define relations explicitly with `@ManyToOne`, etc.",
			"",
			"### Error Handling",
			"",
			"- Use NestJS built-in exceptions (e.g., `NotFoundException`).",
			"- Centralize cross-cutting errors in exception filters.",
			"- Return consistent JSON error shapes.",
			"- Never leak stack traces in production.",
			"",
			"### Security",
			"",
			"- Validate all input with DTOs and pipes.",
			"- Sanitize strings to prevent injection attacks.",
			"- Apply auth guards at the controller or route level.",
			"- Use rate limiting on public endpoints.",
			"",
			"---",
			"",
			"## Testing",
			"",
			"### Unit Tests",
			"",
			"- Test services and controllers in isolation.",
			"- Mock all external dependencies.",
			"- Use `jest.fn()` and `jest.spyOn()` for mocking.",
			"- Name test files `*.spec.ts` next to source files.",
			"- Test behavior, not implementation details.",
			"",
			"### E2E Tests",
			"",
			"- Test critical HTTP flows end-to-end.",
			"- Place E2E tests in `test/` with `*.e2e-spec.ts` names.",
			"- Use a test database, never production data.",
			"- Keep E2E tests fast and deterministic.",
			"",
			"### Running Tests",
			"",
			"- `yarn test` — run all unit tests.",
			"- `yarn test:e2e` — run all E2E tests.",
			"- All tests must pass before merging.",
			"",
			"---",
			"",
			"## Build & CI",
			"",
			"- `yarn build` must complete with zero errors.",
			"- `yarn lint` must pass with no warnings.",
			"- Run `yarn build`, `yarn test`, `yarn test:e2e` before merging.",
			"- Use semantic commit messages (e.g., `feature/`, `fix/`).",
			"- Enforce lint, type-check, and tests in CI pipelines.",
			"",
			"---",
			"",
			"## Feature Implementation Checklist",
			"",
			"1. Create or update the module, controller, and service.",
			"2. Define request and response DTOs with validation.",
			"3. Add or update entity if persistence changes.",
			"4. Write unit tests for new or changed logic.",
			"5. Write or update E2E tests for HTTP flows.",
			"6. Run `yarn build` — must succeed with no errors.",
			"7. Run `yarn test` — all unit tests must pass.",
			"8. Run `yarn test:e2e` — all E2E tests must pass.",
			"9. Commit with a semantic message and push."
		],
		"description": "Copilot instructions for NestJs"
	},
	"copilot-instructions-dotnet": {
		"prefix": "ci-dotnet",
		"body": [
			"# Simple .NET Core Project Instructions",
			"",
			"## Tech Stack",
			"",
			"- **Runtime:** .NET Core / .NET 8+",
			"- **Language:** C# (nullable reference types enabled)",
			"- **Package Manager:** NuGet",
			"- **ORM:** Entity Framework Core",
			"- **Database:** PostgreSQL",
			"- **Testing:** xUnit / NUnit",
			"- **Protocol:** HTTP / REST",
			"",
			"---",
			"",
			"## Project Structure",
			"",
			"- One controller per feature domain.",
			"- Each controller owns its services and models.",
			"- Group DTOs in a `Models/` or `DTOs/` folder per feature.",
			"- Group entities in a `Data/Entities/` folder.",
			"",
			"---",
			"",
			"## Code Style",
			"",
			"### C#",
			"",
			"- Enable nullable reference types in `.csproj`.",
			"- Use `record` for immutable DTOs.",
			"- Use `class` for entities and services.",
			"- Avoid `dynamic`. Use strongly typed objects.",
			"- Add XML documentation to public methods and classes.",
			"",
			"### Controllers",
			"",
			"- Keep controllers thin. No business logic.",
			"- One controller per resource (e.g., `TeamsController`).",
			"- Use HTTP attribute routing: `[HttpGet]`, `[HttpPost]`, `[HttpPut]`, `[HttpDelete]`.",
			"- Return DTOs, never raw entities.",
			"- Use `[ProducesResponseType]` to document responses.",
			"- Use `[FromRoute]`, `[FromQuery]`, `[FromBody]` for input binding.",
			"",
			"### Services",
			"",
			"- All business logic lives in services.",
			"- Inject dependencies via constructor injection.",
			"- Return plain objects or DTOs, not entities.",
			"- Throw appropriate exceptions for error cases.",
			"- Keep methods short and single-purpose.",
			"",
			"### DTOs",
			"",
			"- DTOs define the API contract.",
			"- Use data annotations for validation (`[Required]`, `[MaxLength]`, etc.).",
			"- Create separate DTOs for inputs (Request) and outputs (Response).",
			"- Use distinct Response DTOs (e.g. `UserResponseDto`) effectively acting as View Models.",
			"- Map Entities to Response DTOs in the Service layer (or use a mapper like AutoMapper).",
			"- Use `record` types for immutable request/response DTOs.",
			"",
			"### Entities",
			"",
			"- One entity class per database table.",
			"- Keep entity files in `Data/Entities/` folder.",
			"- Use EF Core data annotations or Fluent API for configuration.",
			"- Never expose entities directly in API responses.",
			"- Define relations explicitly with navigation properties.",
			"",
			"### Error Handling",
			"",
			"- Use built-in exceptions or create custom exceptions.",
			"- Centralize cross-cutting errors in middleware or filters.",
			"- Return consistent JSON error shapes via ProblemDetails.",
			"- Never leak stack traces in production.",
			"",
			"### Security",
			"",
			"- Validate all input with data annotations and model validation.",
			"- Sanitize strings to prevent injection attacks.",
			"- Apply `[Authorize]` at the controller or action level.",
			"- Use rate limiting on public endpoints.",
			"",
			"---",
			"",
			"## Database with PostgreSQL",
			"",
			"### Setup",
			"",
			"- Install `Npgsql.EntityFrameworkCore.PostgreSQL` package.",
			"- Configure connection string in `appsettings.json`.",
			"- Register DbContext in `Program.cs` with Npgsql provider.",
			"",
			"### Migrations",
			"",
			"- Use EF Core migrations to manage schema changes.",
			"- Run `dotnet ef migrations add <MigrationName>` to create.",
			"- Run `dotnet ef database update` to apply migrations.",
			"- Keep migrations in source control.",
			"",
			"### DbContext",
			"",
			"- Define one DbContext class for the application.",
			"- Configure entities via `OnModelCreating` method.",
			"- Use dependency injection to inject DbContext into services.",
			"",
			"---",
			"",
			"## Testing",
			"",
			"### Unit Tests",
			"",
			"- Test services and controllers in isolation.",
			"- Mock all external dependencies with Moq or NSubstitute.",
			"- Name test files `*.Tests.cs` in a separate test project.",
			"- Test behavior, not implementation details.",
			"",
			"### Integration Tests",
			"",
			"- Test critical HTTP flows end-to-end.",
			"- Use `WebApplicationFactory` for integration testing.",
			"- Use a test database, never production data.",
			"- Keep integration tests fast and deterministic.",
			"",
			"### Running Tests",
			"",
			"- `dotnet test` — run all tests.",
			"- All tests must pass before merging.",
			"",
			"---",
			"",
			"## Build & CI",
			"",
			"- `dotnet build` must complete with zero errors.",
			"- `dotnet format --verify-no-changes` to check code formatting.",
			"- Run `dotnet build`, `dotnet test` before merging.",
			"- Use semantic commit messages (e.g., `feature/`, `fix/`).",
			"- Enforce build, format, and tests in CI pipelines.",
			"",
			"---",
			"",
			"## Feature Implementation Checklist",
			"",
			"1. Create or update the controller and service.",
			"2. Define request and response DTOs with validation.",
			"3. Add or update entity if persistence changes.",
			"4. Update DbContext and create migration if needed.",
			"5. Write unit tests for new or changed logic.",
			"6. Write or update integration tests for HTTP flows.",
			"7. Run `dotnet build` — must succeed with no errors.",
			"8. Run `dotnet test` — all tests must pass.",
			"9. Commit with a semantic message and push."
		],
		"description": "Copilot instructions for .NET Core with PostgreSQL"
	},
	"copilot-instructions-python-fastapi": {
		"prefix": "ci-fastapi",
		"body": [
			"# Simple Python FastAPI Project Instructions",
			"",
			"## Tech Stack",
			"",
			"- **Runtime:** Python 3.14+",
			"- **Framework:** FastAPI",
			"- **Package Manager:** Poetry",
			"- **ORM:** SQLAlchemy (Async)",
			"- **Database:** PostgreSQL",
			"- **Testing:** Pytest",
			"- **Protocol:** HTTP / REST",
			"",
			"---",
			"",
			"## Project Structure",
			"",
			"- Organize by domain/feature directories (e.g., `routers/`, `services/`, `schemas/`).",
			"- Use `main.py` for app entry point.",
			"- Group Pydantic models in `schemas/`.",
			"- Group SQLAlchemy models in `models/`.",
			"",
			"---",
			"",
			"## Code Style",
			"",
			"### Python",
			"",
			"- Use Type Hints strictly.",
			"- Use Pydantic models for validation.",
			"- Follow PEP 8 style guide.",
			"- Use async/await for I/O bound operations.",
			"- Add docstrings to functions and classes.",
			"",
			"### Routers (Controllers)",
			"",
			"- Keep routers thin. No business logic.",
			"- Use `APIRouter` to structure routes.",
			"- Use standard HTTP methods: `@router.get`, `@router.post`, etc.",
			"- Return Pydantic models (DTOs), never ORM models directly.",
			"- Use dependency injection (`Depends`) for services.",
			"",
			"### Services",
			"",
			"- All business logic lives in services.",
			"- Inject dependencies (like database sessions) via `Depends`.",
			"- Return plain objects or Pydantic models.",
			"- Raise `HTTPException` for handled errors.",
			"",
			"### DTOs (Pydantic Models)",
			"",
			"- Define API contract using Pydantic `BaseModel`.",
			"- Use `Field` for validation constraints.",
			"- Create separate models for inputs (Create/Update) and outputs (Response).",
			"- Use distinct Response models (e.g., `UserResponse`) acting as View Models.",
			"- Enable `from_attributes = True` (ConfigDict) for ORM mapping.",
			"- Map ORM objects to Response models in the Service or Router.",
			"",
			"### Entities (SQLAlchemy Models)",
			"",
			"- Define tables using SQLAlchemy declarative base.",
			"- Keep models in `models/` directory.",
			"- Use relationships explicitly.",
			"- Never expose SQLAlchemy models directly in responses.",
			"",
			"### Error Handling",
			"",
			"- Use `HTTPException` for API errors.",
			"- Create custom exception handlers in `main.py`.",
			"- Return consistent JSON error responses.",
			"",
			"### Security",
			"",
			"- Validate all inputs with Pydantic.",
			"- Use OAuth2 with Password Flow (or similar) for auth.",
			"- Hash passwords using `passlib` or `bcrypt`.",
			"",
			"---",
			"",
			"## Database with PostgreSQL",
			"",
			"### Setup",
			"",
			"- Use `asyncpg` driver.",
			"- Configure `AsyncEngine` and `AsyncSession`.",
			"- Use Alembic for migrations.",
			"",
			"### Migrations",
			"",
			"- Run `alembic revision --autogenerate -m 'message'` to create.",
			"- Run `alembic upgrade head` to apply.",
			"",
			"---",
			"",
			"## Testing",
			"",
			"### Unit & Integration Tests",
			"",
			"- Use `pytest` for all tests.",
			"- Use `TestClient` or `AsyncClient` (httpx) for integration tests.",
			"- Override database dependencies to use a test database.",
			"- Keep tests fast and isolated.",
			"",
			"### Running Tests",
			"",
			"- `pytest` — run all tests.",
			"- All tests must pass before merging.",
			"",
			"---",
			"",
			"## Build & CI",
			"",
			"- Use `poetry export` or `pip freeze` for requirements.",
			"- Run linters (`ruff`, `black`, `mypy`).",
			"- Run tests in CI pipeline.",
			"",
			"---",
			"",
			"## Feature Implementation Checklist",
			"",
			"1. Create or update router and service.",
			"2. Define request and response Pydantic models.",
			"3. Add or update SQLAlchemy model if needed.",
			"4. Create Alembic migration if DB changes.",
			"5. Write tests for new logic.",
			"6. Run linters and formatters.",
			"7. Run `pytest` to ensure all tests pass.",
			"8. Commit and push."
		],
		"description": "Copilot instructions for Python FastAPI with PostgreSQL"
	},
	"copilot-instructions-firebase": {
		"prefix": "ci-firebase",
		"body": [
			"# Simple Firebase Project Instructions",
			"",
			"## Tech Stack",
			"",
			"- **Platform:** Firebase",
			"- **Runtime:** Cloud Functions (Node.js / TypeScript)",
			"- **Database:** Cloud Firestore (NoSQL)",
			"- **Auth:** Firebase Authentication (Google Auth)",
			"- **Language:** TypeScript (strict mode)",
			"- **Testing:** Jest + Firebase Emulator Suite",
			"",
			"---",
			"",
			"## Project Structure",
			"",
			"- `functions/`: Cloud Functions root.",
			"- `functions/src/`: Source code.",
			"- Group functions by domain/feature (e.g., `src/users/`, `src/orders/`).",
			"- Shared code/interfaces in `src/common/` or `src/shared/`.",
			"- `firestore.rules`: Security rules.",
			"- `storage.rules`: Storage rules.",
			"",
			"---",
			"",
			"## Code Style",
			"",
			"### TypeScript",
			"",
			"- Enable `strict` mode in `tsconfig.json`.",
			"- Use `interface` for Firestore document models.",
			"- avoid `any`. Use `unknown` with validation.",
			"",
			"### Cloud Functions",
			"",
			"- **Callable Functions (`onCall`):** interacting with your frontend client.",
			"- **HTTP Functions (`onRequest`):** Webhooks and public APIs.",
			"- **Triggers:** `onCreate`, `onUpdate`, `onDelete` for side-effects.",
			"- Keep `index.ts` clean; export functions from their modules.",
			"- Use `async/await` for all async operations.",
			"",
			"### Firestore Data Modeling",
			"",
			"- Use **Firestore Converters** for type safety (Map objects to/from Classes/Interfaces).",
			"- Define interfaces for all document shapes.",
			"- Denormalize data for read efficiency (NoSQL pattern).",
			"- Use subcollections for strictly owned data.",
			"",
			"### Security & Auth",
			"",
			"- **Callable Functions:** Always check `context.auth` to verify user identity.",
			"- **Validation:** Validate all arguments using schemas (e.g., Zod) inside the function.",
			"- **Firestore Rules:** Write strict rules. Default to deny all.",
			"- Use Custom Claims for roles (e.g., `admin`, `editor`).",
			"",
			"---",
			"",
			"## Local Development",
			"",
			"- **Use Emulators:** `firebase emulators:start`.",
			"- Develop against usage of `localhost` ports.",
			"- Never connect to production DB during local dev/tests.",
			"",
			"---",
			"",
			"## Testing",
			"",
			"- Use `jest` for unit/integration tests.",
			"- Use `@firebase/rules-unit-testing` for security rules.",
			"- Test `onCall` functions by extracting logic into testable service functions.",
			"",
			"---",
			"",
			"## Deployment",
			"",
			"- `firebase deploy --only functions`.",
			"- Run `npm run build` (tsc) to check for type errors before deploy.",
			"- Version control `firestore.rules` and `firebase.json`.",
			"",
			"---",
			"",
			"## Feature Implementation Checklist",
			"",
			"1. Define the data model interface.",
			"2. Create or update the Cloud Function.",
			"3. Implement/Update Firestore Security Rules.",
			"4. Validate `context.auth` and input data.",
			"5. Test locally using Emulators.",
			"6. Build (`tsc`) and Deploy."
		],
		"description": "Copilot instructions for Firebase (Functions, Firestore, Auth)"
	}
}